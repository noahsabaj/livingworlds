//! Registration utilities and helper types for settings builder
//!
//! This module provides utilities that support the macro system,
//! including configuration types and registration helpers.
//! Based on the proven patterns from plugin_builder/registration.rs.

use crate::settings::types::{
    AudioSettings, ControlSettings, GraphicsSettings, InterfaceSettings, SettingType,
};
use crate::ui::ValueFormat;
use bevy::prelude::*;

/// Configuration for a settings control with metadata
#[derive(Debug, Clone)]
pub struct ControlRegistration {
    /// Type of control being registered
    pub control_type: RegisteredControlType,
    /// Display label for the control
    pub label: String,
    /// Field name in the settings struct
    pub field_name: String,
    /// The SettingType enum variant for event handling
    pub setting_type: SettingType,
    /// Optional validation rules
    pub validation: Option<ValidationRules>,
}

/// Types of controls that can be registered
#[derive(Debug, Clone)]
pub enum RegisteredControlType {
    /// Cycle through enum values
    Cycle {
        /// Available options for cycling
        options: Vec<String>,
    },
    /// Boolean toggle
    Toggle,
    /// Numeric slider
    Slider {
        min: f32,
        max: f32,
        step: Option<f32>,
        format: ValueFormat,
    },
    /// Preset buttons for graphics quality
    Presets {
        /// List of available presets
        presets: Vec<String>,
    },
}

/// Validation rules for settings controls
#[derive(Debug, Clone)]
pub struct ValidationRules {
    /// Minimum allowed value (for numeric types)
    pub min_value: Option<f32>,
    /// Maximum allowed value (for numeric types)
    pub max_value: Option<f32>,
    /// Custom validation function name
    pub custom_validator: Option<String>,
}

/// Configuration for a complete settings tab registration
#[derive(Debug, Clone)]
pub struct TabRegistration {
    /// Name of the tab
    pub name: String,
    /// Type of settings this tab manages
    pub settings_type: SettingsTypeInfo,
    /// List of sections in this tab
    pub sections: Vec<SectionRegistration>,
    /// Generated function names
    pub generated_functions: GeneratedFunctions,
}

/// Information about the settings type being managed
#[derive(Debug, Clone)]
pub struct SettingsTypeInfo {
    /// Rust type name (e.g., "GraphicsSettings")
    pub type_name: String,
    /// Module path to the type
    pub module_path: String,
    /// Whether the type supports presets
    pub supports_presets: bool,
}

/// Configuration for a settings section registration
#[derive(Debug, Clone)]
pub struct SectionRegistration {
    /// Display name of the section
    pub name: String,
    /// Controls within this section
    pub controls: Vec<ControlRegistration>,
    /// Whether this section includes preset buttons
    pub has_presets: bool,
}

/// Names of functions generated by the macro
#[derive(Debug, Clone)]
pub struct GeneratedFunctions {
    /// UI spawning function name
    pub spawn_function: String,
    /// Event handler function name
    pub handler_function: String,
    /// Validation function name (if any)
    pub validation_function: Option<String>,
}

/// Main registrar for settings tabs
pub struct SettingRegistrar;

impl SettingRegistrar {
    /// Register a complete settings tab configuration
    pub fn register_tab(registration: TabRegistration) -> Result<String, RegistrationError> {
        // Validate the registration
        Self::validate_registration(&registration)?;

        // Generate the implementation code
        let implementation = Self::generate_implementation(&registration)?;

        Ok(implementation)
    }

    /// Validate a tab registration
    fn validate_registration(registration: &TabRegistration) -> Result<(), RegistrationError> {
        // Check tab name is valid
        if registration.name.is_empty() {
            return Err(RegistrationError::InvalidConfiguration(
                "Tab name cannot be empty".to_string(),
            ));
        }

        // Validate each section
        for section in &registration.sections {
            Self::validate_section(section)?;
        }

        // Check for duplicate setting types
        let mut setting_types = std::collections::HashSet::new();
        for section in &registration.sections {
            for control in &section.controls {
                if !setting_types.insert(control.setting_type) {
                    return Err(RegistrationError::DuplicateSettings(format!(
                        "Duplicate setting type: {:?}",
                        control.setting_type
                    )));
                }
            }
        }

        Ok(())
    }

    /// Validate a section registration
    fn validate_section(section: &SectionRegistration) -> Result<(), RegistrationError> {
        if section.name.is_empty() {
            return Err(RegistrationError::InvalidConfiguration(
                "Section name cannot be empty".to_string(),
            ));
        }

        if section.controls.is_empty() && !section.has_presets {
            return Err(RegistrationError::InvalidConfiguration(format!(
                "Section '{}' must have at least one control or presets",
                section.name
            )));
        }

        for control in &section.controls {
            Self::validate_control(control)?;
        }

        Ok(())
    }

    /// Validate a control registration
    fn validate_control(control: &ControlRegistration) -> Result<(), RegistrationError> {
        if control.label.is_empty() {
            return Err(RegistrationError::InvalidConfiguration(
                "Control label cannot be empty".to_string(),
            ));
        }

        if control.field_name.is_empty() {
            return Err(RegistrationError::InvalidConfiguration(
                "Control field name cannot be empty".to_string(),
            ));
        }

        // Validate control type specific requirements
        match &control.control_type {
            RegisteredControlType::Slider { min, max, .. } => {
                if min >= max {
                    return Err(RegistrationError::InvalidRange(format!(
                        "Slider '{}': minimum ({}) must be less than maximum ({})",
                        control.label, min, max
                    )));
                }
            }
            RegisteredControlType::Cycle { options } => {
                if options.is_empty() {
                    return Err(RegistrationError::InvalidConfiguration(format!(
                        "Cycle control '{}' must have at least one option",
                        control.label
                    )));
                }
            }
            RegisteredControlType::Presets { presets } => {
                if presets.is_empty() {
                    return Err(RegistrationError::InvalidConfiguration(
                        "Presets must include at least one preset".to_string(),
                    ));
                }
            }
            RegisteredControlType::Toggle => {} // No additional validation needed
        }

        Ok(())
    }

    /// Generate the complete implementation for a settings tab
    fn generate_implementation(
        registration: &TabRegistration,
    ) -> Result<String, RegistrationError> {
        let spawn_function = Self::generate_spawn_function(registration);
        let handler_function = Self::generate_handler_function(registration);
        let helper_functions = Self::generate_helper_functions();

        Ok(format!(
            r#"
// Generated implementation for {tab_name}
{helper_functions}

{spawn_function}

{handler_function}
"#,
            tab_name = registration.name,
            helper_functions = helper_functions,
            spawn_function = spawn_function,
            handler_function = handler_function
        ))
    }

    /// Generate UI spawning function
    fn generate_spawn_function(registration: &TabRegistration) -> String {
        format!(
            r#"
/// Generated UI spawning function for {tab_name}
pub fn {spawn_fn_name}(
    parent: &mut bevy::prelude::ChildSpawner,
    settings: &{settings_type}
) {{
    use crate::ui::{{
        SliderBuilder, ButtonBuilder, PanelBuilder, LabelBuilder,
        ButtonStyle, ValueFormat, PanelStyle
    }};
    use crate::settings::{{components::*, types::SettingType}};

    parent.spawn((
        bevy::prelude::Node {{
            flex_direction: bevy::prelude::FlexDirection::Column,
            row_gap: bevy::prelude::Val::Px(20.0),
            ..default()
        }},
        bevy::prelude::BackgroundColor(bevy::prelude::Color::NONE),
    )).with_children(|content| {{
        {sections}
    }});
}}
"#,
            tab_name = registration.name,
            spawn_fn_name = registration.generated_functions.spawn_function,
            settings_type = registration.settings_type.type_name,
            sections = registration
                .sections
                .iter()
                .map(|section| Self::generate_section_code(section))
                .collect::<Vec<_>>()
                .join("\n")
        )
    }

    /// Generate code for a single section
    fn generate_section_code(section: &SectionRegistration) -> String {
        format!(
            r#"
        // Section: {section_name}
        content.spawn((
            bevy::prelude::Node {{
                flex_direction: bevy::prelude::FlexDirection::Column,
                row_gap: bevy::prelude::Val::Px(15.0),
                margin: bevy::prelude::UiRect::bottom(bevy::prelude::Val::Px(25.0)),
                ..default()
            }},
            bevy::prelude::BackgroundColor(bevy::prelude::Color::NONE),
        )).with_children(|section| {{
            // Section title
            section.spawn((
                bevy::prelude::Text::new("{section_name}"),
                bevy::prelude::TextFont {{
                    font_size: 20.0,
                    ..default()
                }},
                bevy::prelude::TextColor(crate::ui::styles::colors::TEXT_PRIMARY),
            ));

            {controls}
        }});
"#,
            section_name = section.name,
            controls = section
                .controls
                .iter()
                .map(|control| Self::generate_control_code(control))
                .collect::<Vec<_>>()
                .join("\n")
        )
    }

    /// Generate code for a single control
    fn generate_control_code(control: &ControlRegistration) -> String {
        match &control.control_type {
            RegisteredControlType::Cycle { .. } => {
                format!(
                    r#"
            // Cycle: {label}
            crate::ui::ButtonBuilder::new(format!("< {{}} >", settings.{field}.as_str()))
                .style(crate::ui::ButtonStyle::Secondary)
                .with_marker(crate::settings::components::CycleButton {{
                    setting_type: crate::settings::types::SettingType::{setting_type:?}
                }})
                .build(section);
"#,
                    label = control.label,
                    field = control.field_name,
                    setting_type = control.setting_type
                )
            }
            RegisteredControlType::Toggle => {
                format!(
                    r#"
            // Toggle: {label}
            create_toggle_row(section, "{label}", settings.{field}, crate::settings::types::SettingType::{setting_type:?});
"#,
                    label = control.label,
                    field = control.field_name,
                    setting_type = control.setting_type
                )
            }
            RegisteredControlType::Slider {
                min, max, format, ..
            } => {
                format!(
                    r#"
            // Slider: {label}
            crate::ui::SliderBuilder::new({min}, {max})
                .with_label("{label}")
                .with_value(settings.{field})
                .with_format(crate::ui::ValueFormat::{format:?})
                .with_marker(crate::settings::components::SettingsSlider {{
                    setting_type: crate::settings::types::SettingType::{setting_type:?}
                }})
                .build(section);
"#,
                    label = control.label,
                    field = control.field_name,
                    min = min,
                    max = max,
                    format = format,
                    setting_type = control.setting_type
                )
            }
            RegisteredControlType::Presets { presets } => {
                format!(
                    r#"
            // Presets
            section.spawn((
                bevy::prelude::Node {{
                    flex_direction: bevy::prelude::FlexDirection::Row,
                    column_gap: bevy::prelude::Val::Px(10.0),
                    margin: bevy::prelude::UiRect::bottom(bevy::prelude::Val::Px(15.0)),
                    ..default()
                }},
                bevy::prelude::BackgroundColor(bevy::prelude::Color::NONE),
            )).with_children(|preset_row| {{
                {preset_buttons}
            }});
"#,
                    preset_buttons = presets
                        .iter()
                        .map(|preset| format!(
                            r#"
                crate::ui::ButtonBuilder::new("{preset}")
                    .style(crate::ui::ButtonStyle::Secondary)
                    .with_marker(crate::settings::components::PresetButton {{
                        preset: crate::settings::types::GraphicsPreset::{preset}
                    }})
                    .build(preset_row);
"#,
                            preset = preset
                        ))
                        .collect::<Vec<_>>()
                        .join("")
                )
            }
        }
    }

    /// Generate event handler function
    fn generate_handler_function(registration: &TabRegistration) -> String {
        format!(
            r#"
/// Generated event handler for {tab_name}
pub fn {handler_fn_name}(
    mut temp_settings: bevy::prelude::ResMut<crate::settings::types::TempGameSettings>,
    cycle_buttons: bevy::prelude::Query<
        (&bevy::prelude::Interaction, &crate::settings::components::CycleButton, &bevy::prelude::Children),
        (bevy::prelude::Changed<bevy::prelude::Interaction>, bevy::prelude::With<bevy::prelude::Button>)
    >,
    mut toggle_buttons: bevy::prelude::Query<
        (&bevy::prelude::Interaction, &mut crate::settings::components::ToggleButton),
        (bevy::prelude::Changed<bevy::prelude::Interaction>, bevy::prelude::With<bevy::prelude::Button>)
    >,
    sliders: bevy::prelude::Query<
        (&crate::ui::Slider, &crate::settings::components::SettingsSlider),
        bevy::prelude::Changed<crate::ui::Slider>
    >,
    mut text_query: bevy::prelude::Query<&mut bevy::prelude::Text>,
) {{
    {handlers}
}}
"#,
            tab_name = registration.name,
            handler_fn_name = registration.generated_functions.handler_function,
            handlers = Self::generate_all_handlers(registration)
        )
    }

    /// Generate all event handlers
    fn generate_all_handlers(registration: &TabRegistration) -> String {
        format!(
            r#"
    // Handle cycle button interactions
    for (interaction, cycle_button, children) in &cycle_buttons {{
        if *interaction == bevy::prelude::Interaction::Pressed {{
            {cycle_handlers}
        }}
    }}

    // Handle toggle button interactions
    for (interaction, mut toggle_button) in &mut toggle_buttons {{
        if *interaction == bevy::prelude::Interaction::Pressed {{
            toggle_button.enabled = !toggle_button.enabled;
            {toggle_handlers}
        }}
    }}

    // Handle slider interactions
    for (slider, settings_slider) in &sliders {{
        {slider_handlers}
    }}
"#,
            cycle_handlers = Self::generate_cycle_handlers(registration),
            toggle_handlers = Self::generate_toggle_handlers(registration),
            slider_handlers = Self::generate_slider_handlers(registration)
        )
    }

    /// Generate cycle button handlers
    fn generate_cycle_handlers(registration: &TabRegistration) -> String {
        registration
            .sections
            .iter()
            .flat_map(|section| &section.controls)
            .filter(|control| matches!(control.control_type, RegisteredControlType::Cycle { .. }))
            .map(|control| {
                let settings_field = Self::get_settings_field_path(
                    &registration.settings_type.type_name,
                    &control.field_name,
                );
                format!(
                    r#"
            if cycle_button.setting_type == crate::settings::types::SettingType::{setting_type:?} {{
                {settings_field} = {settings_field}.cycle();
                for child in children {{
                    if let Ok(mut text) = text_query.get_mut(*child) {{
                        **text = format!("< {{}} >", {settings_field}.as_str());
                    }}
                }}
            }}
"#,
                    setting_type = control.setting_type,
                    settings_field = settings_field
                )
            })
            .collect::<Vec<_>>()
            .join("")
    }

    /// Generate toggle button handlers
    fn generate_toggle_handlers(registration: &TabRegistration) -> String {
        registration
            .sections
            .iter()
            .flat_map(|section| &section.controls)
            .filter(|control| matches!(control.control_type, RegisteredControlType::Toggle))
            .map(|control| {
                let settings_field = Self::get_settings_field_path(&registration.settings_type.type_name, &control.field_name);
                format!(
                    r#"
            if toggle_button.setting_type == crate::settings::types::SettingType::{setting_type:?} {{
                {settings_field} = toggle_button.enabled;
            }}
"#,
                    setting_type = control.setting_type,
                    settings_field = settings_field
                )
            })
            .collect::<Vec<_>>()
            .join("")
    }

    /// Generate slider handlers
    fn generate_slider_handlers(registration: &TabRegistration) -> String {
        registration
            .sections
            .iter()
            .flat_map(|section| &section.controls)
            .filter(|control| matches!(control.control_type, RegisteredControlType::Slider { .. }))
            .map(|control| {
                let settings_field = Self::get_settings_field_path(
                    &registration.settings_type.type_name,
                    &control.field_name,
                );
                format!(
                    r#"
        if settings_slider.setting_type == crate::settings::types::SettingType::{setting_type:?} {{
            {settings_field} = slider.value;
        }}
"#,
                    setting_type = control.setting_type,
                    settings_field = settings_field
                )
            })
            .collect::<Vec<_>>()
            .join("")
    }

    /// Get the correct path to a settings field
    fn get_settings_field_path(settings_type: &str, field_name: &str) -> String {
        match settings_type {
            "GraphicsSettings" => format!("temp_settings.0.graphics.{}", field_name),
            "AudioSettings" => format!("temp_settings.0.audio.{}", field_name),
            "InterfaceSettings" => format!("temp_settings.0.interface.{}", field_name),
            "ControlSettings" => format!("temp_settings.0.controls.{}", field_name),
            _ => format!("temp_settings.0.{}", field_name), // Fallback
        }
    }

    /// Generate helper functions needed by all tabs
    fn generate_helper_functions() -> String {
        r#"
/// Helper function to create toggle row (replicates existing pattern)
fn create_toggle_row(
    parent: &mut bevy::prelude::ChildSpawner,
    label: &str,
    enabled: bool,
    setting_type: crate::settings::types::SettingType,
) {
    parent.spawn((
        bevy::prelude::Node {
            flex_direction: bevy::prelude::FlexDirection::Row,
            justify_content: bevy::prelude::JustifyContent::SpaceBetween,
            align_items: bevy::prelude::AlignItems::Center,
            margin: bevy::prelude::UiRect::bottom(bevy::prelude::Val::Px(15.0)),
            ..default()
        },
        bevy::prelude::BackgroundColor(bevy::prelude::Color::NONE),
    )).with_children(|row| {
        // Label
        row.spawn((
            bevy::prelude::Text::new(label),
            bevy::prelude::TextFont {
                font_size: 18.0,
                ..default()
            },
            bevy::prelude::TextColor(crate::ui::styles::colors::TEXT_PRIMARY),
        ));

        // Toggle button
        crate::ui::ButtonBuilder::new(if enabled { "âœ“" } else { "" })
            .style(if enabled {
                crate::ui::ButtonStyle::Success
            } else {
                crate::ui::ButtonStyle::Secondary
            })
            .with_marker(crate::settings::components::ToggleButton {
                setting_type,
                enabled,
            })
            .build(row);
    });
}
"#
        .to_string()
    }
}

/// Validation results for settings registration
pub type ValidationResult = Result<(), RegistrationError>;

/// Registration error types
#[derive(Debug, Clone)]
pub enum RegistrationError {
    /// Invalid configuration provided
    InvalidConfiguration(String),
    /// Duplicate setting types detected
    DuplicateSettings(String),
    /// Invalid range parameters
    InvalidRange(String),
    /// Missing required field
    MissingRequiredField(String),
    /// Code generation failed
    GenerationError(String),
}

impl std::fmt::Display for RegistrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RegistrationError::InvalidConfiguration(msg) => {
                write!(f, "Invalid configuration: {}", msg)
            }
            RegistrationError::DuplicateSettings(msg) => {
                write!(f, "Duplicate settings: {}", msg)
            }
            RegistrationError::InvalidRange(msg) => {
                write!(f, "Invalid range: {}", msg)
            }
            RegistrationError::MissingRequiredField(msg) => {
                write!(f, "Missing required field: {}", msg)
            }
            RegistrationError::GenerationError(msg) => {
                write!(f, "Code generation error: {}", msg)
            }
        }
    }
}

impl std::error::Error for RegistrationError {}
